# Experiment 04: Quantum Mutual Information and Dimensional Compression

**Experiment ID:** 04
**Status:** Specification
**Created:** 2026-01-30
**Protocol Version:** 1.0

---

## 1. Motivation

Experiments 01-03 established that classical correlation structure can reveal geometric information beyond topology, with compression ratio delta ~ 0.25-0.46 for long-range correlations. However, these used *classical* correlations as a proxy for quantum entanglement.

This experiment takes the critical step: **testing actual quantum systems** to measure whether quantum mutual information reveals dimensional compression invisible to topological analysis.

### From the Theoretical Substrate

> "Does quantum correlation structure provide geometric information that causal structure alone cannot capture?"

The core prediction:
> "For quantum states with significant entanglement, d_Q < d_C"

Where:
- d_C = dimension from lattice topology (causal/graph structure)
- d_Q = dimension from quantum mutual information structure

### Why Quantum?

Classical correlations in Exp01-03 were *imposed* on graphs. Quantum correlations are *intrinsic* to the state:
- Entanglement creates non-local correlations that violate Bell inequalities
- Quantum mutual information captures both classical and quantum correlations
- Area-law entanglement in ground states connects to holographic principles

---

## 2. Research Question

**Does quantum entanglement create dimensional compression measurable via mutual information geometry?**

Specifically:
1. Do entangled states show d_Q < d_topo while product states show d_Q ≈ d_topo?
2. Does compression scale with entanglement entropy?
3. Does the holographic prediction (d_Q → boundary dimension) hold for maximally entangled bipartitions?

---

## 3. Quantum Framework

### 3.1 Quantum Mutual Information

For a bipartite quantum system with density matrix ρ_AB:

**I(A:B) = S(ρ_A) + S(ρ_B) - S(ρ_AB)**

Where S(ρ) = -Tr(ρ log ρ) is the von Neumann entropy.

Properties:
- I(A:B) ≥ 0 always
- I(A:B) = 0 iff ρ_AB = ρ_A ⊗ ρ_B (product state)
- I(A:B) = 2S(ρ_A) for pure states (since S(ρ_AB) = 0)
- Captures both classical and quantum correlations

### 3.2 From MI to Distance

Convert mutual information to distance metric:

**D(i,j) = sqrt(2 * (S_max - I(i:j)))**

Where S_max = log(d) for d-dimensional local Hilbert space.

This maps:
- High MI (strongly correlated) → small distance
- Zero MI (independent) → large distance

### 3.3 Dimension Extraction

Same methodology as Exp01-03:
1. Compute pairwise MI matrix for all qubit pairs
2. Convert to distance matrix
3. Apply MDS/Isomap embedding
4. Find dimension via reconstruction error threshold

---

## 4. Computational Strategy

### 4.1 State Representation

Full density matrix simulation:
- N qubits → 2^N dimensional Hilbert space
- Density matrix: 2^N × 2^N complex entries
- Memory: 2^(2N) × 16 bytes (complex128)

| N (qubits) | Hilbert dim | Memory (density matrix) |
|------------|-------------|------------------------|
| 4 | 16 | 4 KB |
| 6 | 64 | 64 KB |
| 8 | 256 | 1 MB |
| 10 | 1024 | 16 MB |
| 12 | 4096 | 256 MB |
| 14 | 16384 | 4 GB |
| 16 | 65536 | 64 GB |

**Feasible range:** N = 4 to 12 qubits on standard hardware (16 GB RAM)

### 4.2 Partial Trace for Reduced Density Matrices

To compute I(i:j), we need:
- ρ_i = Tr_{not i}(ρ) - trace out all qubits except i
- ρ_j = Tr_{not j}(ρ) - trace out all qubits except j
- ρ_ij = Tr_{not i,j}(ρ) - trace out all qubits except i and j

For each pair (i,j), compute:
- S(ρ_i), S(ρ_j), S(ρ_ij)
- I(i:j) = S(ρ_i) + S(ρ_j) - S(ρ_ij)

### 4.3 Entanglement Patterns to Test

**1. Product State (Baseline)**
|ψ⟩ = |0⟩^⊗N

- No entanglement
- I(i:j) = 0 for all pairs
- Expected: d_Q = N-1 (maximal, no structure)

**2. GHZ State (Global Entanglement)**
|GHZ⟩ = (|00...0⟩ + |11...1⟩) / sqrt(2)

- Maximal global entanglement
- All qubits equally correlated
- Expected: d_Q << d_topo (strong compression)

**3. W State (Symmetric Entanglement)**
|W⟩ = (|100...0⟩ + |010...0⟩ + ... + |00...01⟩) / sqrt(N)

- Different entanglement structure than GHZ
- Robust to single-qubit loss
- Expected: d_Q < d_topo

**4. 1D Cluster State (Topological Entanglement)**
Generated by CZ gates on linear chain:
|cluster⟩ = Π_⟨i,j⟩ CZ_ij |+⟩^⊗N

- Entanglement follows 1D topology
- Universal resource for measurement-based QC
- Expected: d_Q ≈ 1 (matching 1D structure)

**5. 2D Cluster State (Surface Code)**
CZ gates on 2D lattice

- Entanglement follows 2D topology
- Expected: d_Q ≈ 2 (but test for compression)

**6. Random Pure State (Haar Random)**
|ψ⟩ = U|0⟩^⊗N where U is Haar-random unitary

- Typical highly entangled state
- Near-maximal entanglement
- Expected: d_Q low (but how low?)

**7. Ground State of XXZ Model**
H = Σ_⟨i,j⟩ (X_i X_j + Y_i Y_j + Δ Z_i Z_j)

- Physical Hamiltonian
- Entanglement depends on Δ parameter
- Test: Does d_Q change with Δ?

---

## 5. Test Matrix

### 5.1 System Sizes

| N | Geometry | Replications | Purpose |
|---|----------|--------------|---------|
| 4 | Chain | 10 | Baseline, fast |
| 6 | Chain | 10 | Small system |
| 8 | Chain | 10 | Medium system |
| 8 | 2×4 grid | 10 | 2D topology |
| 10 | Chain | 5 | Larger 1D |
| 12 | Chain | 5 | Limit of tractability |
| 12 | 3×4 grid | 5 | 2D at limit |

### 5.2 State Types per Configuration

For each (N, geometry):
- Product state
- GHZ state
- W state
- Cluster state (matching geometry)
- 5 random pure states

**Total configurations:** ~250

### 5.3 Measurements

For each configuration:
1. Generate quantum state
2. Compute full MI matrix (N×N)
3. Convert to distance matrix
4. Extract d_topo (from geometry alone)
5. Extract d_Q (from MI structure)
6. Compute δ = (d_topo - d_Q) / d_topo
7. Compute entanglement entropy S_ent

---

## 6. Pre-Registered Predictions

### P1: Product State Baseline
**Claim:** Product states show no compression.
**Threshold:** |δ| < 0.1 for all product states
**Rationale:** No correlations → no compression

### P2: GHZ Compression
**Claim:** GHZ states show significant compression.
**Threshold:** δ > 0.4 for GHZ states with N ≥ 6
**Rationale:** Global entanglement creates strong correlation structure

### P3: Cluster State Matches Topology
**Claim:** 1D cluster states have d_Q ≈ 1.
**Threshold:** d_Q < 1.5 for 1D cluster states
**Rationale:** Entanglement follows 1D structure

### P4: Random State Compression
**Claim:** Haar-random states show compression.
**Threshold:** δ > 0.25 for random states with N ≥ 8
**Rationale:** High entanglement → geometric shortcuts

### P5: Entanglement-Compression Correlation
**Claim:** Compression correlates with entanglement entropy.
**Threshold:** Pearson r(S_ent, δ) > 0.7
**Rationale:** More entanglement → more compression

### P6: 2D Holographic Prediction
**Claim:** For 2D lattice with strong entanglement, d_Q approaches boundary dimension.
**Threshold:** d_Q < 1.5 for 2D cluster states (boundary is 1D)
**Rationale:** Holographic principle predicts area-law dimensional reduction

---

## 7. Implementation Plan

### 7.1 Module Structure

```
experiments/04-quantum-mutual-information/
├── README.md
├── DEVLOG.md
├── spec.md
├── claims.json
├── verification_gates.json
├── src/
│   ├── __init__.py
│   ├── quantum_states.py      # State generation (GHZ, W, cluster, etc.)
│   ├── mutual_information.py  # MI computation, partial traces
│   ├── quantum_dimension.py   # Dimension extraction from MI
│   ├── main.py                # Test matrix runner
│   └── tests/
│       ├── __init__.py
│       ├── test_quantum_states.py
│       ├── test_mutual_information.py
│       └── test_quantum_dimension.py
├── output/
│   └── metrics.json
├── reports/
│   ├── mi_heatmaps.png
│   ├── compression_by_state.png
│   ├── entanglement_correlation.png
│   └── predictions_summary.png
└── paper/
    ├── README.md
    ├── main.tex
    └── main.pdf
```

### 7.2 Dependencies

- **numpy** - Array operations
- **scipy** - Linear algebra, eigenvalue decomposition
- **qutip** (optional) - Quantum toolbox for verification
- **matplotlib** - Visualization

### 7.3 Core Algorithms

**partial_trace(rho, keep_qubits, N):**
```python
# Trace out all qubits except keep_qubits
# Returns reduced density matrix
```

**von_neumann_entropy(rho):**
```python
# S(ρ) = -Tr(ρ log ρ)
eigenvalues = np.linalg.eigvalsh(rho)
eigenvalues = eigenvalues[eigenvalues > 1e-12]  # Numerical stability
return -np.sum(eigenvalues * np.log2(eigenvalues))
```

**mutual_information_matrix(state, N):**
```python
# Compute I(i:j) for all pairs
MI = np.zeros((N, N))
for i in range(N):
    for j in range(i+1, N):
        rho_i = partial_trace(state, [i], N)
        rho_j = partial_trace(state, [j], N)
        rho_ij = partial_trace(state, [i, j], N)
        MI[i,j] = MI[j,i] = von_neumann_entropy(rho_i) + von_neumann_entropy(rho_j) - von_neumann_entropy(rho_ij)
return MI
```

---

## 8. Diagnostics and Validation

### 8.1 Sanity Checks

1. **Product state:** All MI values should be 0
2. **GHZ state:** MI(i,j) should be equal for all pairs
3. **Pure state:** S(ρ_full) = 0
4. **Positivity:** All MI values ≥ 0

### 8.2 Numerical Stability

- Eigenvalue cutoff: λ < 10^-12 treated as 0
- Density matrix hermiticity enforcement
- Trace normalization check

### 8.3 Comparison with Known Results

- GHZ MI: I(i:j) = 1 bit for all pairs (known result)
- W state MI: I(i:j) = 2/N * H(1/N) (verify)
- Cluster state: Check against literature values

---

## 9. Success Criteria

| Outcome | Predictions | Interpretation |
|---------|-------------|----------------|
| Full success | 6/6 pass | Quantum correlation reveals geometric compression |
| Strong success | 5/6 pass | Effect is real with minor deviations |
| Partial success | 4/6 pass | Effect exists but predictions need refinement |
| Weak signal | 2-3/6 pass | Effect uncertain, methodology may need work |
| Failure | 0-1/6 pass | Either no effect or methodology broken |

### Critical Predictions

- **P1:** If product states show compression, methodology is broken
- **P2:** If GHZ doesn't show compression, core hypothesis fails
- **P5:** If entanglement doesn't correlate with compression, mechanism is wrong

---

## 10. Risks and Mitigations

### Risk 1: Numerical Instability
**Detection:** Negative MI values, non-hermitian matrices
**Mitigation:** Eigenvalue cutoffs, hermiticity enforcement, double precision

### Risk 2: Memory Limits
**Detection:** N > 12 causes OOM
**Mitigation:** Stay within N ≤ 12, use sparse representations if needed

### Risk 3: MI → Distance Conversion
**Detection:** Distance matrix not metric (triangle inequality violations)
**Mitigation:** Test multiple conversion formulas, use MDS stress as diagnostic

### Risk 4: Dimension Estimation Variance
**Detection:** High std in d_Q estimates (as seen in Exp03)
**Mitigation:** Use more replications for random states, report confidence intervals

---

## 11. Timeline Estimate

- **Implementation:** 4-6 hours (quantum state generation, MI computation)
- **Testing:** 1-2 hours (unit tests, sanity checks)
- **Execution:** 30-60 minutes (250 configurations)
- **Analysis & Paper:** 3-4 hours

---

## 12. Deliverables Checklist

- [ ] spec.md (this file)
- [ ] claims.json
- [ ] verification_gates.json
- [ ] src/quantum_states.py
- [ ] src/mutual_information.py
- [ ] src/quantum_dimension.py
- [ ] src/main.py
- [ ] src/tests/*.py
- [ ] output/metrics.json
- [ ] reports/*.png (4+ figures)
- [ ] paper/README.md
- [ ] paper/main.tex
- [ ] paper/main.pdf (visually verified)

---

## Document Metadata

**Experiment:** 04
**Title:** Quantum Mutual Information and Dimensional Compression
**Status:** Specification Complete
**Created:** 2026-01-30
**Dependencies:** Dimension extraction methods from Exp01-03
**Key Innovation:** First experiment using actual quantum states rather than classical proxies
