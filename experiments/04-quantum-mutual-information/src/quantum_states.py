"""
Quantum state generation for Experiment 04.

Generates various quantum states for testing dimensional compression:
- Product states (no entanglement)
- GHZ states (global entanglement)
- W states (symmetric entanglement)
- Cluster states (topological entanglement)
- Haar random states (typical entanglement)
"""

import numpy as np
from typing import Tuple, Optional, List
from scipy.stats import unitary_group


def product_state(n_qubits: int) -> np.ndarray:
    """
    Create product state |0...0>.

    No entanglement - all qubits independent.

    Args:
        n_qubits: Number of qubits

    Returns:
        State vector of dimension 2^n_qubits
    """
    dim = 2 ** n_qubits
    state = np.zeros(dim, dtype=np.complex128)
    state[0] = 1.0  # |00...0>
    return state


def ghz_state(n_qubits: int) -> np.ndarray:
    """
    Create GHZ state (|00...0> + |11...1>) / sqrt(2).

    Maximal global entanglement - all qubits equally correlated.

    Args:
        n_qubits: Number of qubits

    Returns:
        State vector
    """
    dim = 2 ** n_qubits
    state = np.zeros(dim, dtype=np.complex128)
    state[0] = 1.0 / np.sqrt(2)  # |00...0>
    state[-1] = 1.0 / np.sqrt(2)  # |11...1>
    return state


def w_state(n_qubits: int) -> np.ndarray:
    """
    Create W state: (|10...0> + |01...0> + ... + |00...1>) / sqrt(N).

    Symmetric entanglement - robust to single-qubit loss.

    Args:
        n_qubits: Number of qubits

    Returns:
        State vector
    """
    dim = 2 ** n_qubits
    state = np.zeros(dim, dtype=np.complex128)

    # Add each basis state with exactly one 1
    amplitude = 1.0 / np.sqrt(n_qubits)
    for i in range(n_qubits):
        # Basis state with 1 in position i (from right)
        index = 2 ** i
        state[index] = amplitude

    return state


def cluster_state_1d(n_qubits: int) -> np.ndarray:
    """
    Create 1D cluster state on linear chain.

    Generated by applying CZ gates between neighbors starting from |+>^N.

    Args:
        n_qubits: Number of qubits

    Returns:
        State vector
    """
    # Start with |+>^N
    plus = np.array([1, 1], dtype=np.complex128) / np.sqrt(2)
    state = plus.copy()
    for _ in range(n_qubits - 1):
        state = np.kron(state, plus)

    # Apply CZ gates between neighbors
    dim = 2 ** n_qubits
    for i in range(n_qubits - 1):
        state = apply_cz(state, i, i + 1, n_qubits)

    return state


def cluster_state_2d(rows: int, cols: int) -> np.ndarray:
    """
    Create 2D cluster state on grid.

    CZ gates applied between all neighboring qubits on 2D lattice.

    Args:
        rows: Number of rows
        cols: Number of columns

    Returns:
        State vector
    """
    n_qubits = rows * cols

    # Start with |+>^N
    plus = np.array([1, 1], dtype=np.complex128) / np.sqrt(2)
    state = plus.copy()
    for _ in range(n_qubits - 1):
        state = np.kron(state, plus)

    # Apply CZ gates between neighbors (row-major indexing)
    for r in range(rows):
        for c in range(cols):
            idx = r * cols + c
            # Horizontal neighbor
            if c < cols - 1:
                state = apply_cz(state, idx, idx + 1, n_qubits)
            # Vertical neighbor
            if r < rows - 1:
                state = apply_cz(state, idx, idx + cols, n_qubits)

    return state


def apply_cz(state: np.ndarray, qubit_i: int, qubit_j: int, n_qubits: int) -> np.ndarray:
    """
    Apply controlled-Z gate between two qubits.

    CZ|ab> = (-1)^(a*b) |ab>

    Args:
        state: State vector
        qubit_i: First qubit index (0-indexed from left)
        qubit_j: Second qubit index
        n_qubits: Total number of qubits

    Returns:
        Modified state vector
    """
    result = state.copy()
    dim = 2 ** n_qubits

    for k in range(dim):
        # Check if both qubits are 1
        bit_i = (k >> (n_qubits - 1 - qubit_i)) & 1
        bit_j = (k >> (n_qubits - 1 - qubit_j)) & 1

        if bit_i == 1 and bit_j == 1:
            result[k] *= -1

    return result


def haar_random_state(n_qubits: int, seed: Optional[int] = None) -> np.ndarray:
    """
    Generate Haar-random pure state.

    Typical highly entangled state from uniform distribution on state space.

    Args:
        n_qubits: Number of qubits
        seed: Random seed

    Returns:
        State vector
    """
    if seed is not None:
        np.random.seed(seed)

    dim = 2 ** n_qubits

    # Generate random complex vector
    real_part = np.random.randn(dim)
    imag_part = np.random.randn(dim)
    state = real_part + 1j * imag_part

    # Normalize
    state = state / np.linalg.norm(state)

    return state


def state_to_density_matrix(state: np.ndarray) -> np.ndarray:
    """
    Convert pure state vector to density matrix.

    rho = |psi><psi|

    Args:
        state: State vector

    Returns:
        Density matrix
    """
    return np.outer(state, np.conj(state))


def get_state_by_name(name: str, n_qubits: int, geometry: str = 'chain',
                       seed: Optional[int] = None) -> Tuple[np.ndarray, dict]:
    """
    Get quantum state by name.

    Args:
        name: State name ('product', 'ghz', 'w', 'cluster', 'random')
        n_qubits: Number of qubits
        geometry: 'chain' or 'grid' (for cluster states)
        seed: Random seed (for random states)

    Returns:
        Tuple of (state vector, metadata dict)
    """
    metadata = {
        'name': name,
        'n_qubits': n_qubits,
        'geometry': geometry,
        'seed': seed
    }

    if name == 'product':
        state = product_state(n_qubits)
        metadata['entanglement_type'] = 'none'

    elif name == 'ghz':
        state = ghz_state(n_qubits)
        metadata['entanglement_type'] = 'global'

    elif name == 'w':
        state = w_state(n_qubits)
        metadata['entanglement_type'] = 'symmetric'

    elif name == 'cluster':
        if geometry == 'chain':
            state = cluster_state_1d(n_qubits)
            metadata['entanglement_type'] = 'topological_1d'
        else:
            # Parse grid dimensions from geometry (e.g., '2x4')
            if 'x' in geometry:
                rows, cols = map(int, geometry.split('x'))
                if rows * cols != n_qubits:
                    raise ValueError(f"Grid {geometry} doesn't match n_qubits={n_qubits}")
                state = cluster_state_2d(rows, cols)
                metadata['entanglement_type'] = 'topological_2d'
                metadata['grid_shape'] = (rows, cols)
            else:
                state = cluster_state_1d(n_qubits)
                metadata['entanglement_type'] = 'topological_1d'

    elif name == 'random':
        state = haar_random_state(n_qubits, seed)
        metadata['entanglement_type'] = 'random'

    else:
        raise ValueError(f"Unknown state name: {name}")

    return state, metadata


def get_topology_dimension(n_qubits: int, geometry: str) -> float:
    """
    Get the topological dimension for a given geometry.

    Args:
        n_qubits: Number of qubits
        geometry: 'chain' or grid specification (e.g., '2x4')

    Returns:
        Topological dimension
    """
    if geometry == 'chain':
        return 1.0
    elif 'x' in geometry:
        return 2.0
    else:
        return 1.0  # Default to 1D


def verify_state_normalization(state: np.ndarray, tol: float = 1e-10) -> bool:
    """Check if state is normalized."""
    return abs(np.linalg.norm(state) - 1.0) < tol


def verify_density_matrix(rho: np.ndarray, tol: float = 1e-10) -> dict:
    """
    Verify properties of density matrix.

    Returns dict with verification results.
    """
    n = rho.shape[0]

    # Check hermiticity
    is_hermitian = np.allclose(rho, rho.conj().T, atol=tol)

    # Check trace = 1
    trace_one = abs(np.trace(rho) - 1.0) < tol

    # Check positive semidefinite
    eigenvalues = np.linalg.eigvalsh(rho)
    is_positive = np.all(eigenvalues >= -tol)

    # Check purity (Tr(rho^2) = 1 for pure states)
    purity = np.real(np.trace(rho @ rho))
    is_pure = abs(purity - 1.0) < tol

    return {
        'is_hermitian': is_hermitian,
        'trace_one': trace_one,
        'is_positive': is_positive,
        'is_pure': is_pure,
        'purity': purity,
        'min_eigenvalue': float(np.min(eigenvalues))
    }
